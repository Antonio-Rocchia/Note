\RequirePackage[l2tabu, orthodox]{nag}

\documentclass
[10pt,        % Font size(10 default)
 a4paper,     % Paper size and format
 %draft,      % Draft mode will improve compilation time but not render figures
 onecolumn,   % Onecolumn or two columns
 fleqn,       % fleqn=left align of math formulas
 %leqno,      % Math formula counter to the left of the formula(right default)
 oneside,     % When printing, oneside=fronte twoside=fronte-retro
 notitlepage, % Does not reserve a page for the title, titlepage does
 %openany      % Open chapter anywhere, openright open on right page
]{article}    % article, book, report, letter, beamer

%region Preamble

%region Metadata
\title{Le system call nel sistema Unix}
\author{Antonio Rocchia}
%endregion Metadata

%region Language and encoding settings
\usepackage[utf8]{inputenc}                 % Input encoding for characters written in the .tex document
\usepackage[T1]{fontenc}                    % Output encoding for characters written in the .pdf document
\usepackage[italian, english]{babel}        % Languages used in this file, switch with \selectlanguage{language}, default is italian
%endregion Language and encoding settings

%region Page layout settings
%region Page dimension, margin, header and footer dimensions
\usepackage{geometry}
\geometry{
paper=a4paper,              % Type of paper used
hmargin=2cm,                % Shorthand for left and right margin
bindingoffset=1cm,          % Offset from page binding to the start of the inner margin
top=1cm,                    % Top margin
bottom=0.8cm,               % Bottom margin
includeheadfoot=true,       % Include header and footer in the body size
headsep=1cm,                % Distance from header and main text
headheight=12pt,            % Height of the header
footskip=2cm,               % Distance from the bottom of the foot the end of body
}
%endregion Page dimension, margin, header and footer dimensions

%region Header and footer content
\usepackage{fancyhdr}
\pagestyle{plain}
%endregion Header and footer content

%region Microtype
\usepackage[final,babel=true]{microtype}
%endregion Microtype

%region Parskip
\usepackage{parskip}
%endregion Parskip

%endregion Page layout settings

%region Hyperlinks
\usepackage{hyperref}
\makeatletter
\hypersetup{
colorlinks=true,
linkcolor=blue,
filecolor=magenta,
urlcolor=blue,
pdftitle={\@title},
pdfauthor={\@author}
}
\makeatother
    
\urlstyle{same}
%endregion Hyperlinks

%endregion Preamble

%region modules
%% Code ---------------------------
%%% Dependencies ******************
    \usepackage[dvipsnames]{xcolor} % Used by: listings
%%% ***********************************
\usepackage{listings} % Code display "https://www.ctan.org/pkg/listings"
\lstset{
    backgroundcolor=\color{White},
    basicstyle=\ttfamily,
    identifierstyle=\color{Black},
    stringstyle=\color{Green},
    keywordstyle=\color{NavyBlue},
    commentstyle=\color{Gray},
    extendedchars=true,
    showstringspaces=false,
    % caption
    title=\lstname,
    % frames
    frame=lines,
    breaklines=true,
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
}

\lstnewenvironment{C++}[1][]
    {\lstset{language=C++},#1}
    {}

\lstnewenvironment{C}[1][]
    {\lstset{language=C},#1}
    {}

%%% Snippets """""""""""""""""""""""""
% snippet [C++] "C++ Code block" bA
% \begin{C++}[name=]
% 	
% \end{C++}
% endsnippet

% snippet [C] "C Code block" bA
% \begin{C}[name=]
% 	
% \end{C}
% endsnippet

% snippet code_i "Code Inline" bA
% \lstinline[language=]!"code"!
% endsnippet

% snippet import_code "Import code from a file" bA
% \lstinputlisting[language=,name=]{}
% endsnippet

%% --------------------------------

\usepackage{subfiles}

%endregion modules

%region Body
\begin{document}

%region Title and TOC
\microtypesetup{protrusion=false} % disables protrusion locally in the document
\maketitle          
\tableofcontents % prints Table of Contents
\microtypesetup{protrusion=true} % enables protrusion
%endregion Title and TOC

\section{Le system call di Unix}
Il kernel di Linux espone un API di funzioni che un utente o un processo può chiamare per richiedere che un servizio venga svolto dal sistema operativo a livello kernel.

Ogni linguaggio di programmazione fa uso di queste system call in tantissimi modi. Ad esempio per aprire e creare file, leggere da un file, inizializzare un processo e così via.

Nei linguaggi di programmazione moderni le system call sono esposte al programmatore tramite una serie di funzioni(wrapper) che ne semplificano l'uso ed impediscono che vengano commesse violazioni dell'API.
\section{Lista delle system call Unix}
\begin{itemize}
    \item Controllo dei processi/thread:
        \begin{itemize}
            \item Creazione processi
            \item Terminazione processi
            \item Sospensione processi
            \item Attesa terminazione
            \item Sostituzione di un processo
        \end{itemize}
    \item Gestione del file system
    \item Gestione dei dispositivi
    \item Comunicazione
\end{itemize}

\section{Wrapper delle system call nel linguaggio C}
\subsection{fork()}
fork - Crea un processo figlio
\begin{C}[Includere fork]
    #include <unistd.h>

    int fork();
\end{C}
\paragraph{Descrizione:}
\lstinline[language=C]!fork()! genera un processo figlio duplicando il processo che chiama questa funzione.
Il nuovo processo è chiamato \textit{figlio}, il processo chiamante è chiamato \textit{padre}

Il processo figlio ed il padre \textit{continuano l'esecuzione in spazi di memoria diversi}. Al momento della fork() \textit{il figlio ottiene una copia dello spazio di memoria del padre}
Il padre ed il figlio sono identici eccetto per queste differenze:
\begin{itemize}
    \item Il figlio ha il suo PID unico e diverso dal padre
    \item il figlio non eredita allarmi (\textit{alarm()}) dal padre
    \item Il segnale di terminazione del figlio è sempre \textit{SIGCHLD}
    \item Il figlio eredita le copie dei descrittori(\textit{file descriptor}) aperti dal padre
    \item Il figlio eredita una copia dello stream di direttori aperti dal padre (\textit{opendir()})
\end{itemize}
\paragraph{Valore di ritorno:}
In caso di successo, il processo padre riceve il PID del processo figlio appena generato, e il figlio riceve 0. 
In caso di fallimento, il padre riceve \textit{-1}, non viene generato nessun processo figlio e \textit{errno} viene impostata correttamente.
\paragraph{Esempi:}
Di seguito vengono riportati alcuni esempi di codice che mostrano gli utilizzi tipici di fork(). Si cerca dove possibile di spiegare al meglio cio che succede durante l'esecuzione
%Esempio 1
\lstinputlisting[language=C,name=fork_base.c,firstline=1,lastline=9]{esempi/fork/fork_base.c}
Il processo figlio ottiene una copia dello spazio di memoria del padre, in questo caso la variabile pid inizializzata a 0.
Il processo padre ed il processo figlio proseguono l'esecuzione allo stesso momento (in parallelo), ma con una differenza, \textit{fork restituisce il PID del processo figlio generato al padre e restituisce 0 al figlio}.
Questo valore viene assegnato alla variabile pid.
Ora possiamo scrivere del codice che permetta al processo di capire se è il padre o il figlio.
\lstinputlisting[language=C,name=fork_base.c,firstline=9]{esempi/fork/fork_base.c}
Il processo figlio esegue lo stesso codice del processo padre. Pertanto nella maggior parte dei casi è necessario terminare l'esecuzione del figlio prima di uscire dal blocco \textit{if(pid==0)}
\lstinputlisting[name=Output fork_base.c]{esempi/fork/fork_base.output}
%paragraph{Todo: aggiungere più esempi}

\subsection{getpid(),getppid()}
getpid, getppid - restituisce l'identificatore del processo(PID)
\begin{C}[Includere getpid()]
#include <unistd.h>

int getpid();
int getppid();
\end{C}
\paragraph{Descrizione:}
\textit{getpid()} restituisce al processo che chiama la funzione il sui identificatore di processo \textit{(PID)}.

\textit{getppid()} restituisce al processo che chiama la funzione l'identificativo di processo \textit{(PID)} del suo processo padre.
\paragraph{Controllo degli errori}
Questa system call non fallisce mai. Non è necessario alcun controllo.
\paragraph{Valore di ritorno}
\begin{itemize}
    \item getpid(): Restituisce il pid del processo che la chiama
    \item getppid(): Restituisce il pid del padre del processo che la chiama.
\end{itemize}
\paragraph{Esempi:}
Di seguito alcuni esempi di codice che mostrano l'utilizo di getpid() e getppid().

%Esempio 1
\lstinputlisting[language=C,name=getpid() in azione,firstline=1]{esempi/getpid/getpid_base.c}
\lstinputlisting[name=Output getpid_base.c]{esempi/getpid/getpid_base.output}

\subsection{exit()}
exit - Causa la terminazione \textit{volontaria} di un processo.

Un processo può terminare involontariamente, se si tentano azioni illegali o se il processo viene interrotto tramite \textit{segnale} (\textit{kill()}), o volontariamente, se viene eseguita l'ultima istruzione o si esegue la funzione exit()
\begin{C}
#include <stdlib.h>
    
void exit(int status);
\end{C}
    
\paragraph{exit o return?}
Se una procedura raggiunge un return, restuisce un valore alla procedura che l'ha invocata, il processo termina solo se il main effettua un return. exit() invece termina il processo in esecuzione, anche se non viene chiamato dal main.

\paragraph{Descrizione}
La funzione exit() causa la normale terminazione di un processo.
\begin{itemize}
    \item Il byte meno significativo di \textit{status} è restituito al processo padre.
    \item Tutte le stream di stdio \textit{(stdin,stdout,stderr)} vengono chiuse.
    \item La libreria standard di C \textit{stdlib.h} specifica due costanti \lstinline!(EXIT_SUCCESS, EXIT_FAILURE)! che possono essere usate per specificare l'esito della terminazione.
    \item Se un processo padre termina prima della terminazione di un figlio. Il processo figlio viene "\textit{adottato}" dal processo init (pid==1), che ne rileva automaticamente lo stato di terminazione.
\end{itemize}

\paragraph{Controllo degli errori}
Questa system call non fallisce main. Non è necessario alcun controllo.

\paragraph{Valore di ritorno}
Questa system call non ha nessun valore di ritorno.

\paragraph{Esempi}
Todo esempi

\subsection{pipe()}
pipe - Crea una pipe.
\begin{C}[name=pipe()]
#include <unistd.h>

int pipe(int pipefd[2]);
\end{C}

\paragraph{Descrizione:}
pipe() crea una pipe, un \textit{canale di comunicazione tra processi unidirezionale} per la trasmissione dei dati. 

L'array \textit{int pipefd[2]} è usato per specificare due \textit{descrittori file (file descriptors)} che rappresentano gli estremi della pipe:
\begin{itemize}
    \item pipefd[0] rappresenta il lato di lettura della pipe.
    \item pipefd[1] rappresenta il lato di scrittura della pipe.
\end{itemize}

Quando tutti i descrittori di file che si riferiscono al lato scrittura della pipe vengono chiusi, viene scritto \textit{EOF}(end of file) sulla pipe. Il lato lettura potrà leggerlo tramite \textit{read} e restitirà 0.

\lstinputlisting[language=C,name=Chiusura lato scrittura,firstline=0]{esempi/pipe/close_write.c}

Quando vengono chiusi tutti i descrittori di file che si riferiscono al lato lettura, ogni write verso la pipe causera un \textit{SIGPIPE} verso il processo che prova a leggere. Questa situazione potrà quindi essere gestita come ogni altro segnale.

\lstinputlisting[language=C,name=Chiusura lato lettura,firstline=0]{esempi/pipe/close_read.c}

La pipe non ha una dimensione. Il canale di comunicazione della pipe è una \textit{byte stream}, quindi non esiste il concetto di limite del file. Il kernel si occupa di gestire la pipe.
\begin{itemize}
    \item Se la pipe è piena, write sarà sospensiva.
    \item Se la pipe è vuota o non ha la quantità di byte richiesti da una read, read sarà sospensiva.
\end{itemize}

La capacità effettiva della pipe dipende dall'implementazione. In ogni caso è preferibile che il programma non sia progettato facendo affidamento ad una particolare capacità: Un applicazione dovrebbe essere progettata in modo che il processo che legge consumi i dati appena sono disponibili, cosi che il processo di scrittura non rimanga bloccato.

Un applicazione che usa pipe() e fork() dovrebbe usare close() per chiudere file descriptor duplicati di cui non ha bisogno. Se il processo figlio deve solo scrivere dati, chiudera il lato lettura della pipe. close(pipefd[0]);

\lstinputlisting[language=C,name=Chiudere i file descriptor inutilizzati,firstline=0]{esempi/pipe/close_duplicate_fd.c}

\paragraph{Valore di ritorno:}
In caso di successo, pipe() restituisce 0. In caso di errore restituisce -1, pipefd[2] rimane invariato e viene impostato un valore per \textit{errno}

\paragraph{Esempi:}
Nel seguente esempio il programma crea una pipe, dopo effettua una fork per creare un processo figlio. Il figlio ottiene un duplicato dei descrittori dei file che fanno riferimento alla pipe creata dal padre. Dopo la fork ogni processo chiude i descrittori di cui non hanno più bisogno. Il padre scrive poi una stringa passata al programma per argomento nella pipe, il figlio la legge e la scrive su \textit{stdout}
\lstinputlisting[language=C,name=Tipico uso di pipe(),firstline=0]{esempi/pipe/pipe_from_man.c}









\end{document}
%endregion Body
